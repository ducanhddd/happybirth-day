<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Dot Matrix Morphing 3D Countdown</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
  html, body {
      background: #000;
      margin: 0; padding: 0;
      width: 100vw; height: 100vh;
      overflow: hidden;
  }
  body {
      display: flex; align-items: center; justify-content: center;
      width: 100vw; height: 100vh;
      background: radial-gradient(ellipse at center, #0c0c1d 0%, #000 100%);
  }
  #space-canvas {
      display: block;
      width: 100vw; height: 100vh;
      position: absolute; left:0; top:0;
      z-index: 2;
      background: transparent;
      filter: drop-shadow(0 0 10px #fff2);
      touch-action: none;
      user-select: none;
  }
  .msg3d {
      position: absolute;
      left: 50%; top: 44%;
      transform: translate(-50%,-50%);
      color: #fff;
      font-size: 2.8em;
      z-index: 5;
      text-align: center;
      text-shadow: 0 0 32px #fff, 0 0 24px #fff2;
      letter-spacing: 2px;
      font-weight: bold;
      filter: drop-shadow(0 2px 18px #fff8);
      pointer-events: none;
      animation: fadeInPop .8s cubic-bezier(.34,1.56,.64,1);
      opacity: 0.97;
      white-space: nowrap;
      text-wrap: nowrap;
  }
  @keyframes fadeInPop {
      0% { opacity: 0; transform: scale(0.7) translate(-50%,-50%);}
      80% { opacity: 1; transform: scale(1.08) translate(-50%,-50%);}
      100% { opacity: 1; transform: scale(1) translate(-50%,-50%);}
  }
  </style>
</head>
<body>
<canvas id="space-canvas"></canvas>
<div id="final-msg" class="msg3d" style="display:none;">üéâ Ch√∫c m·ª´ng sinh nh·∫≠t! üéâ</div>
<script>
/* ==== CONFIG ==== */
const DOTS = 420; // s·ªë ch·∫•m v≈© tr·ª•
const DOT_SIZE = 11; // px
const DOT_COLOR = "#fff";
const SPACE_RADIUS = 280; // px, v√πng v≈© tr·ª• ban ƒë·∫ßu
const DOTMATRIX_ROWS = 20, DOTMATRIX_COLS = 13; // dot matrix s·ªë
const DOTMATRIX_SIZE = 320; // px
const MORPH_DURATION = 1100; // ms
const HOLD_DURATION = 800; // ms gi·ªØa c√°c pha

// Dot matrix bitmap t·ª´ng s·ªë (20x13, b·∫°n c√≥ th·ªÉ tƒÉng size n·∫øu mu·ªën n√©t h∆°n)
const BIG_NUM = {
"3":[
"0001111111000",
"0011111111100",
"0111000011110",
"0110000001110",
"0000000001110",
"0000000001110",
"0000000011100",
"0000001111000",
"0000111110000",
"0000111110000",
"0000001111100",
"0000000011110",
"0000000001110",
"0000000001110",
"0110000001110",
"0111000011110",
"0011111111100",
"0001111111000",
"0000000000000",
"0000000000000"
],
"2":[
"0001111111000",
"0011111111100",
"0111000011110",
"0110000001110",
"0000000001110",
"0000000001110",
"0000000011110",
"0000000111100",
"0000001111000",
"0000011110000",
"0000111100000",
"0001111000000",
"0011110000000",
"0111100000000",
"0111111111110",
"0111111111110",
"0000000000000",
"0000000000000",
"0000000000000",
"0000000000000"
],
"1":[
"0000001110000",
"0000011110000",
"0000111110000",
"0001111110000",
"0001111110000",
"0000001110000",
"0000001110000",
"0000001110000",
"0000001110000",
"0000001110000",
"0000001110000",
"0000001110000",
"0000001110000",
"0000001110000",
"0011111111100",
"0011111111100",
"0000000000000",
"0000000000000",
"0000000000000",
"0000000000000"
]
};
// ----
const canvas = document.getElementById('space-canvas');
const ctx = canvas.getContext('2d');
let W = window.innerWidth, H = window.innerHeight;
function resizeCanvas(){
    W = window.innerWidth; H = window.innerHeight;
    canvas.width = W; canvas.height = H;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

/* ---- Dot Universe ---- */
function randSphere(r){
    // L·∫•y 1 ƒëi·ªÉm ng·∫´u nhi√™n tr√™n m·∫∑t c·∫ßu b√°n k√≠nh r
    const u = Math.random();
    const v = Math.random();
    const theta = 2 * Math.PI * u;
    const phi = Math.acos(2 * v - 1);
    const x = r * Math.sin(phi) * Math.cos(theta);
    const y = r * Math.sin(phi) * Math.sin(theta);
    const z = r * Math.cos(phi);
    return {x, y, z};
}
const dots = [];
for(let i=0; i<DOTS; i++){
    let pt = randSphere(SPACE_RADIUS * (0.7 + 0.3*Math.random()));
    dots.push({
        home: {...pt}, // V·ªã tr√≠ v≈© tr·ª•
        pos: {...pt},
        vel: {x:0,y:0,z:0},
        target: {...pt},
        color: DOT_COLOR,
        active: false
    });
}

/* ---- Dot matrix s·ªë l·ªõn ---- */
function getNumberDotTargets(num){
    // Tr·∫£ v·ªÅ c√°c v·ªã tr√≠ 3D (x,y,z) ƒë·ªÉ c√°c dot h·ª£p th√†nh s·ªë dot matrix
    let map = BIG_NUM[num];
    let cell = DOTMATRIX_SIZE / DOTMATRIX_ROWS;
    let offsetX = -cell * (DOTMATRIX_COLS/2-0.5);
    let offsetY = -cell * (DOTMATRIX_ROWS/2-0.5);
    let positions = [];
    for(let r=0; r<DOTMATRIX_ROWS; r++){
        for(let c=0; c<DOTMATRIX_COLS; c++){
            if(map[r][c]==="1"){
                // ƒê·∫∑t dot l√™n m·∫∑t ph·∫≥ng z=0 (gi·ªëng nh∆∞ b·∫£ng s·ªë n·ªïi)
                positions.push({
                    x: offsetX + c*cell + (Math.random()-0.5)*2, // th√™m ch√∫t random cho "hologram"
                    y: offsetY + r*cell + (Math.random()-0.5)*2,
                    z: 0
                });
            }
        }
    }
    return positions;
}

/* ---- Morphing Animation ---- */
function morphToNumber(num){
    // ƒê∆∞a c√°c dot v·ªÅ v·ªã tr√≠ t·∫°o s·ªë (dot matrix)
    let targs = getNumberDotTargets(num);
    // Shuffle ƒë·ªÉ hi·ªáu ·ª©ng dot h·ª£p v√†o s·ªë ƒë·∫πp h∆°n
    let targsUsed = new Array(targs.length).fill(false);
    for(let i=0; i<dots.length; i++){
        let idx = -1, minD = 1e9;
        // t√¨m v·ªã tr√≠ g·∫ßn nh·∫•t ch∆∞a d√πng
        for(let j=0; j<targs.length; j++){
            if(targsUsed[j]) continue;
            let dx = dots[i].pos.x - targs[j].x, dy = dots[i].pos.y - targs[j].y, dz = dots[i].pos.z - targs[j].z;
            let d = dx*dx+dy*dy+dz*dz;
            if(d < minD){ minD = d; idx = j;}
        }
        if(idx>=0){
            targsUsed[idx] = true;
            dots[i].target = {...targs[idx]};
            dots[i].active = true;
        } else {
            // Dot d∆∞, tr√¥i ra xa (·∫©n b·ªõt ch·∫•m th·ª´a)
            dots[i].target = {...dots[i].home, z: dots[i].home.z+100+Math.random()*80};
            dots[i].active = false;
        }
    }
}
function morphToSpace(){
    // ƒê∆∞a c√°c dot v·ªÅ v·ªã tr√≠ v≈© tr·ª•
    for(let i=0; i<dots.length; i++){
        dots[i].target = {...dots[i].home};
        dots[i].active = false;
    }
}

/* ---- Animate ---- */
let morphState = "space"; // ho·∫∑c "number"
let morphStart = 0;
function animateMorph(){
    let now = performance.now();
    let p = Math.min(1, (now-morphStart)/MORPH_DURATION);
    // Ease
    let t = 0.5 - 0.5*Math.cos(Math.PI*p);
    for(let i=0; i<dots.length; i++){
        // Interpolate v·ªã tr√≠
        dots[i].pos.x = dots[i].pos.x + (dots[i].target.x - dots[i].pos.x)*t;
        dots[i].pos.y = dots[i].pos.y + (dots[i].target.y - dots[i].pos.y)*t;
        dots[i].pos.z = dots[i].pos.z + (dots[i].target.z - dots[i].pos.z)*t;
    }
}

/* ---- Perspective projection ---- */
function project3D(pt){
    // Camera ·ªü (0,0,viewZ), nh√¨n v·ªÅ g·ªëc
    const viewZ = 650;
    let scale = viewZ/(viewZ - pt.z);
    let x = pt.x * scale + W/2;
    let y = pt.y * scale + H/2;
    return {x,y,scale};
}

/* ---- Draw ---- */
function draw(){
    ctx.clearRect(0,0,W,H);
    // V·∫Ω c√°c dot
    for(let i=0; i<dots.length; i++){
        let pt = dots[i].pos;
        let pr = project3D(pt);
        let size = DOT_SIZE * pr.scale * (dots[i].active?1.2:1);
        ctx.beginPath();
        ctx.arc(pr.x, pr.y, size/2, 0, 2*Math.PI, false);
        ctx.globalAlpha = dots[i].active ? 0.97 : 0.29;
        ctx.fillStyle = dots[i].active ? '#fff' : '#fff7';
        ctx.shadowColor = dots[i].active ? "#fff" : "#fff";
        ctx.shadowBlur = dots[i].active ? 16 : 8;
        ctx.fill();
        ctx.shadowBlur = 0;
    }
    ctx.globalAlpha = 1;
}
function loop(){
    animateMorph();
    draw();
    requestAnimationFrame(loop);
}
loop();

/* ---- Countdown Logic ---- */
const countdowns = [3,2,1];
let idx = 0;
function nextCount(){
    if(idx < countdowns.length){
        morphToSpace();
        morphStart = performance.now();
        setTimeout(()=>{
            morphToNumber(countdowns[idx]);
            morphStart = performance.now();
            idx++;
            setTimeout(nextCount, MORPH_DURATION + HOLD_DURATION);
        }, MORPH_DURATION + HOLD_DURATION);
    } else {
        morphToSpace();
        morphStart = performance.now();
        setTimeout(()=>{
            document.getElementById('final-msg').style.display = '';
        }, MORPH_DURATION + 400);
    }
}
// B·∫Øt ƒë·∫ßu countdown sau khi load
window.onload = ()=> {
    morphToSpace(); morphStart = performance.now();
    setTimeout(nextCount, 900);
};
</script>
</body>
</html>
